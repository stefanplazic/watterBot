{"version":3,"sources":["../src/index.js"],"names":["app","port","process","env","PORT","PAGE_ACCESS_TOKEN","use","bodyParser","urlencoded","extended","json","express","static","path","join","__dirname","post","req","res","body","object","entry","forEach","webhook_event","messaging","console","log","sender_psid","sender","id","message","handleMessage","postback","handlePostback","status","send","sendStatus","get","VERIFY_TOKEN","mode","query","token","challenge","received_message","response","text","textEntered","toLowerCase","push","item","callSendAPI","received_postback","payload","request_body","rep","err","error","listen"],"mappings":"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","file":"index.js","sourcesContent":["import express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport path from 'path';\r\nimport logger from 'morgan';\r\nimport request from 'request';\r\n\r\nconst app = express();\r\nconst port = process.env.PORT || 3000;\r\nconst PAGE_ACCESS_TOKEN = 'EAAipPa65D7sBADDa5nK4qSIPk9VjS0GPaTIUjIDr6bMf5Ns6OHGR3ZBOYt4eH5kTZCcClCK8C24O9ac2iWNfy44eIvDcvvcAfXhGNlYyEwAgBxlXbveYTj8ewrDn6b2dc227z5n6w4UbeivPAmTXkBVbOyKFETL4Ge7kmiPQZDZD';\r\n\r\napp.use(logger('dev'));\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\napp.use(bodyParser.json());\r\napp.use(express.static(path.join(__dirname, 'public')));\r\n\r\n\r\n\r\n/*create a test webhook*/\r\n// Creates the endpoint for our webhook \r\napp.post('/webhook', (req, res) => {\r\n\r\n    let body = req.body;\r\n\r\n    // Checks this is an event from a page subscription\r\n    if (body.object === 'page') {\r\n\r\n        // Iterates over each entry - there may be multiple if batched\r\n        body.entry.forEach(function (entry) {\r\n\r\n            // Gets the message. entry.messaging is an array, but \r\n            // will only ever contain one message, so we get index 0\r\n            let webhook_event = entry.messaging[0];\r\n            console.log(webhook_event);\r\n\r\n            // Get the sender PSID\r\n            let sender_psid = webhook_event.sender.id;\r\n\r\n            if (webhook_event.message) {\r\n                handleMessage(sender_psid, webhook_event.message);\r\n            } else if (webhook_event.postback) {\r\n                handlePostback(sender_psid, webhook_event.postback);\r\n            }\r\n        });\r\n\r\n        // Returns a '200 OK' response to all requests\r\n        res.status(200).send('EVENT_RECEIVED');\r\n    } else {\r\n        // Returns a '404 Not Found' if event is not from a page subscription\r\n        res.sendStatus(404);\r\n    }\r\n\r\n});\r\n\r\napp.get('/webhook', (req, res) => {\r\n\r\n    /** UPDATE YOUR VERIFY TOKEN **/\r\n    const VERIFY_TOKEN = \"stef\";\r\n\r\n    // Parse params from the webhook verification request\r\n    let mode = req.query['hub.mode'];\r\n    let token = req.query['hub.verify_token'];\r\n    let challenge = req.query['hub.challenge'];\r\n\r\n    // Check if a token and mode were sent\r\n    if (mode && token) {\r\n\r\n        // Check the mode and token sent are correct\r\n        if (mode === 'subscribe' && token === VERIFY_TOKEN) {\r\n\r\n            // Respond with 200 OK and challenge token from the request\r\n            console.log('WEBHOOK_VERIFIED');\r\n            res.status(200).send(challenge);\r\n\r\n        } else {\r\n            // Responds with '403 Forbidden' if verify tokens do not match\r\n            res.sendStatus(403);\r\n        }\r\n    }\r\n});\r\n\r\n// Handles messages events\r\nfunction handleMessage(sender_psid, received_message) {\r\n    let response = [];\r\n\r\n    // Check if the message contains text\r\n    if (received_message.text) {\r\n        const textEntered = received_message.text.toLowerCase();\r\n\r\n        if (textEntered === 'menu' || textEntered === 'back') {\r\n            response.push({\r\n                \"text\": \"Wellcome to this super menu\",\r\n                \"quick_replies\": [\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"Info\",\r\n                        \"payload\": \"action@info\"\r\n                    },\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"Change alerts\",\r\n                        \"payload\": \"action@ChangeAlerts\"\r\n                    }\r\n                ]\r\n            });\r\n        }\r\n        else if (textEntered === 'info') {\r\n\r\n            response.push({\r\n                \"text\": \"Thank you for asking such a cool question! ðŸ™‚ I am the best waterbot ever writen. My author is Stefan Plazic\",\r\n                \"quick_replies\": [\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"Back\",\r\n                        \"payload\": \"action@back\"\r\n                    }\r\n                ]\r\n            });\r\n        }\r\n        else if (textEntered === \"let's dig in\") {\r\n            response.push({\r\n                \"text\": \"Ok let's get rolling! ðŸ™‚ Tell us how many cups of watter you drink daily?\",\r\n                \"quick_replies\": [\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"1-2 cups\",\r\n                        \"payload\": \"action@cup\"\r\n                    },\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"3-5 cup\",\r\n                        \"payload\": \"action@cup\"\r\n                    },\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"6 or more cup\",\r\n                        \"payload\": \"action@cup\"\r\n                    },\r\n                    {\r\n                        \"content_type\": \"text\",\r\n                        \"title\": \"don't count\",\r\n                        \"payload\": \"action@cup\"\r\n                    }\r\n                ]\r\n            });\r\n        }\r\n        else\r\n            // Create the payload for a basic text message\r\n            response.push({\r\n                \"text\": `Sorry I am a stupid bot, if you have any questions type Menu`\r\n            });\r\n    }\r\n\r\n\r\n    response.forEach(async (item) => { await callSendAPI(sender_psid, item); });\r\n}\r\n\r\n// Handles messaging_postbacks events\r\nfunction handlePostback(sender_psid, received_postback) {\r\n    let response = [];\r\n\r\n    // Get the payload for the postback\r\n    let payload = received_postback.payload;\r\n\r\n    // Set the response based on the postback payload\r\n    if (payload === 'action@getStarted') {\r\n        response.push({ \"text\": \"Hi Stefan! I will be your personal water trainer ðŸ™‚ you can call me Shakira ðŸ’§\" });\r\n        response.push({ \"text\": \"What I can do for you? â˜‘  Daily water reminders \\n â˜‘  Personalized AI recommendations\\n â˜‘  Number of cups of water drank this week\\n â˜‘  Tips about water drinking\" });\r\n\r\n        response.push({\r\n            \"text\": \"Are you ready for this journey?\",\r\n            \"quick_replies\": [\r\n                {\r\n                    \"content_type\": \"text\",\r\n                    \"title\": \"Let's dig in\",\r\n                    \"payload\": \"action@digIn\"\r\n                }\r\n            ]\r\n        }\r\n        );\r\n\r\n    }\r\n\r\n    // Send the message to acknowledge the postback\r\n    response.forEach(async (item) => { await callSendAPI(sender_psid, item); });\r\n\r\n}\r\n\r\n// Sends response messages via the Send API\r\nasync function callSendAPI(sender_psid, response) {\r\n    // Construct the message body\r\n    let request_body = {\r\n        \"recipient\": {\r\n            \"id\": sender_psid\r\n        },\r\n        \"message\": response\r\n    }\r\n    try {\r\n        const rep = request({\r\n            \"uri\": \"https://graph.facebook.com/v2.6/me/messages\",\r\n            \"qs\": { \"access_token\": PAGE_ACCESS_TOKEN },\r\n            \"method\": \"POST\",\r\n            \"json\": request_body\r\n        });\r\n\r\n    }\r\n    catch (err) {\r\n        console.error(err);\r\n    }\r\n}\r\n\r\n//listen to the port\r\napp.listen(port, () => { console.log('Node server listening on port ' + port); });\r\n\r\n\r\n"]}